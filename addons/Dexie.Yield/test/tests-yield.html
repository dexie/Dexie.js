<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Dexie.Yield Unit tests</title>
    <link rel="stylesheet" href="../../../test/qunit.css">
</head>
<body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="../../../test/qunit.js"></script>
    <script src="../../../src/Dexie.js"></script>
    <script src="../../Dexie.Yield/Dexie.Yield.js"></script>
<script>
    "use strict";
        var db = new Dexie("test-yield-db2");
        var async = Dexie.Yield.async,
            spawn = Dexie.Yield.spawn;

        db.version(1).stores({
            friends: '++id,name,*groups',
            pets: '++id,name'
        });

        asyncTest ("db.transaction() with yield", async(function* () {
            var finallyWasReached = false;
            try {
                yield db.delete();
                ok(true, "db deleted");
                yield db.open();
                ok(true, "db opened");
                yield db.transaction('rw', 'friends', 'pets', function* () {
                    // Add a cat and store it's final ID
                    var catId = yield db.pets.add({ name: "Tito", kind: "cat" });
                    // Add a dog in the same way.
                    var dogId = yield db.pets.add({ name: "Josephina", kind: "dog" });
                    // Add a friend who owns the pets
                    db.friends.add({ name: "Gurra G", pets: [catId, dogId] });

                    var gurra = yield db.friends.where('name').equals("Gurra G").first();
                    ok(!!gurra, "Gurra could be found with yield");

                    // Now retrieve the pet objects that Gurra is referring to:
                    var gurrasPets = yield db.pets.where('id').anyOf(gurra.pets).toArray();
                    equal(gurrasPets.length, 2, "Gurras all two pets could be retrieved via yield");
                    equal(gurrasPets[0].kind, "cat", "Gurras first pet is a cat");
                    equal(gurrasPets[1].kind, "dog", "Gurras second pet is a dog");
                });

            } catch(e) {
                ok(false, "Caught error: " + e);
            } finally {
                finallyWasReached = true;
            }
            ok(finallyWasReached, "finally was reached");
            yield db.delete();
            start();
        }));

        asyncTest ("Catching indexedDB error event", 2, async(function* ()
        {
            try {
                yield db.delete();
                yield db.open();
                yield db.pets.add({id: 1, name: "Tidi", kind: "Honeybadger"});
                ok(true, "Should come so far");
                yield db.pets.add({id: 1, name: "Todoo", kind: "Snake"}); // Should generate an IDB error event!
                ok(false, "Should not come here");
            } catch (e) {
                equal(e.name, "ConstraintError", "Caught indexedDB DOMError event ConstraintError");
            }
            yield db.delete();
            start();
        }));

        asyncTest ("Catching error prevents transaction from aborting", 5, async(function* () {
            try {
                yield db.delete();
                yield db.open();
                yield db.transaction('rw', 'pets', function*(){
                    try {
                        yield db.pets.add({id: 1, name: "Tidi", kind: "Honeybadger"});
                        ok(true, "Should come so far");
                        yield db.pets.add({id: 1, name: "Todoo", kind: "Snake"}); // Should generate an IDB error event!
                        ok(false, "Should not come here");
                    } catch (e) {
                        equal(e.name, "ConstraintError", "Caught indexedDB DOMError event ConstraintError");
                    }
                });
                ok (true, "Should come here - transaction committed because we caught the error");

                ok ((yield db.pets.get(1)), "A pet with ID 1 exists in DB");
                equal ((yield db.pets.get(1)).name, "Tidi", "It was Tidi in the first position");
            } finally {
                yield db.delete();
                start();
            }
        }));

        asyncTest("Transaction not committing when not catching error event", 4, async(function* ()
        {
            try {
                yield db.delete();
                yield db.open();
                yield db.transaction('rw', 'pets', function* ()
                {
                    yield db.pets.add({id: 1, name: "Tidi", kind: "Honeybadger"});
                    ok(true, "Should come so far");
                    yield db.pets.add({id: 1, name: "Todoo", kind: "Snake"}); // Should generate an IDB error event!
                    ok(false, "Should not come here");
                });
                ok(false, "Should not come here");

            } catch (e) {

                ok(true, "Transaction should fail");
                equal (e.name, "ConstraintError", "Error caught was a ConstraintError!");
                equal ((yield db.pets.count()), 0, "Pets table should still be empty because transaction failed");

            } finally {
                yield db.delete();
                start();
            }
        }));

        asyncTest("Should allow yielding a non-promise", async(function* () {
            try {
                var x = yield 3;
                equal(x, 3, "Could yield a non-promise");
            } catch (e) {
                ok(false, "Yielding a non-Thenable wasn't be allowed");
            } finally {
                start();
            }
        }));

        asyncTest("Should allow yielding an array with a mix of values and thenables", async(function* () {
            try {
                var results = yield [1, 2, Dexie.Promise.resolve(3)];
                equal(results.length, 3, "Yielded array is of size 3");
                equal(results[0], 1, "First value is 1");
                equal(results[1], 2, "Second value is 2");
                equal(results[2], 3, "Third value is 3");
            } catch (e) {
                ok(false, "Got exception when trying to do yield an array of mixed values/promises");
            } finally {
                start();
            }
        }));

        asyncTest("Should allow yielding an array of non-promises only", function () {
            spawn (function*()
            {
                var results = yield [1,2,3];
                equal(results.length, 3, "Yielded array is of size 3");
                equal(results[0], 1, "First value is 1");
                equal(results[1], 2, "Second value is 2");
                equal(results[2], 3, "Third value is 3");
            }).catch (function(e) {
                ok(false, e);
            }).then(start);
        });

        asyncTest("Should allow yielding an empty array", function () {
            spawn (function*()
            {
                var results = yield [];
                equal(results.length, 0, "Yielded array is of size 0");
            }).catch (function(e) {
                ok(false, e);
            }).then(start);
        });


        asyncTest("Should allow yielding an array of different kind of any kind of promise", function () {
            spawn (function*()
            {
                var results = yield [Promise.resolve(1), Dexie.Promise.resolve(2), Promise.resolve(3)];
                equal(results.length, 3, "Yielded array is of size 3");
                equal(results[0], 1, "First value is 1");
                equal(results[1], 2, "Second value is 2");
                equal(results[2], 3, "Third value is 3");
                return 4;
            }).then (function(x) {
                equal(x, 4, "Finally got the value 4");
            }).catch (function(e) {
                ok(false, "Something is rotten in the state of Denmark: " + e);
            }).then(start);
        });

        asyncTest("Throw after yield", function () {
            spawn (function*()
            {
                try {
                    yield 3;
                    ok(true, "yielded a value");
                    throw "error";
                } catch (e) {
                    ok(e === "error", "Catched exception: " + e);
                }
                return 4;
            }).then (function(x) {
                equal(x, 4, "Finally got the value 4");
            }).catch (function(e) {
                ok(false, "Something is rotten in the state of Denmark: " + e);
            }).then(start);
        });
            
        asyncTest("Throw before yield", function () {
            spawn (function*()
            {
                try {
                    throw "error";
                } catch (e) {
                    ok(e === "error", "Catched exception: " + e);
                }
                return 4;
            }).then (function(x) {
                equal(x, 4, "Finally got the value 4");
            }).catch (function(e) {
                ok(false, "Something is rotten in the state of Denmark: " + e);
            }).then(start);
        });

        asyncTest("Catch rejected promise", function () {
            spawn (function*() {
                try {
                    yield new Promise(function(resolve, reject) { reject("fault fault!"); });
                    ok(false, "Shouldn't come here");
                } catch (e) {
                    ok(e === "fault fault!", "Catched exception: " + e);
                }
                return 4;
            }).then (function(x) {
                equal(x, 4, "Finally got the value 4");
            }).catch (function(e) {
                ok(false, "Something is rotten in the state of Denmark: " + e);
            }).then(start);
        });

        asyncTest("Catch rejected promise in an array", function () {
            spawn (function*() {
                try {
                    yield [1, 2, new Promise(function(resolve, reject) { reject("fault fault!"); }), 4];
                    ok(false, "Shouldn't come here");
                } catch (e) {
                    ok(e === "fault fault!", "Catched exception: " + e);
                }
                return 4;
            }).then (function(x) {
                equal(x, 4, "Finally got the value 4");
            }).catch (function(e) {
                ok(false, "Something is rotten in the state of Denmark: " + e);
            }).then(start);
        });

        asyncTest("Should allow returning a promise", function () {
            spawn (function*()
            {
                return Promise.resolve(3);
            }).then (function(result) {
                equal(result, 3, "Returning a directly should also be allowed");
            }).catch (function(e) {
                ok(false, e);
            }).then(start);
        });

        asyncTest("Should be able to do 'return yield Promise.resolve(x);'", function () {
            spawn (function*()
            {
                return yield Promise.resolve(3);
            }).then (function() {
                ok(true, "Should be able to do 'return yield Promise.resolve(x);'");
            }).catch (function(e) {
                ok(false, "Error occurred: " + e);
            }).then(start);
        });

        asyncTest("Arrow functions and let", function() {
            spawn(function*() {
                let x = yield [1, 2, 3];
                let y = x.map(a => a - 1);
                equal(y[0], 0);
                equal(y[1], 1);
                equal(y[2], 2);
            }).finally(start);
        });

    </script>
</body>
</html>
